# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j0YKUQm-h_XRb7i54KGq7phkFuIiHLBK
"""

# Instalar bibliotecas necessárias
!pip install deap
!pip install pulp

# Importar bibliotecas
import random
import numpy as np
import matplotlib.pyplot as plt
from deap import base, creator, tools, algorithms
import requests
from io import StringIO
from pulp import *

# Função para carregar instância da CVRPLIB
def load_cvrp_instance(url):
    response = requests.get(url)
    data = response.text
    lines = data.split('\n')

    coords = []
    demands = []
    capacity = None
    reading_coords = False
    reading_demands = False

    for line in lines:
        if line.startswith("CAPACITY"):
            capacity = int(line.split()[-1])
        elif line.startswith("NODE_COORD_SECTION"):
            reading_coords = True
            continue
        elif line.startswith("DEMAND_SECTION"):
            reading_coords = False
            reading_demands = True
            continue
        elif line.startswith("DEPOT_SECTION"):
            break
        elif reading_coords:
            parts = line.split()
            if len(parts) >= 3:
                coords.append((float(parts[1]), float(parts[2])))
        elif reading_demands:
            parts = line.split()
            if len(parts) >= 2:
                demands.append(int(parts[1]))

    return coords, demands, capacity

# Calcular distância euclidiana entre dois pontos
def euclidean_distance(p1, p2):
    return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

# Calcular a matriz de distâncias
def calculate_distance_matrix(coords):
    n = len(coords)
    distances = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            if i != j:
                distances[i][j] = euclidean_distance(coords[i], coords[j])
    return distances

# Função para dividir o cromossomo em rotas válidas
def split_routes(individual, demands, capacity):
    routes = []
    current_route = []
    current_load = 0

    for customer in individual:
        demand = demands[customer + 1]
        if current_load + demand <= capacity:
            current_route.append(customer + 1)
            current_load += demand
        else:
            if current_route:
                routes.append(current_route)
            current_route = [customer + 1]
            current_load = demand

    if current_route:
        routes.append(current_route)

    return routes

# Função para decodificar um indivíduo em rotas
def decode_individual(individual, demands, capacity):
    routes = []
    current_route = []
    current_demand = 0

    for customer in individual:
        demand = demands[customer + 1]
        if current_demand + demand <= capacity:
            current_route.append(customer + 1)
            current_demand += demand
        else:
            if current_route:
                routes.append(current_route)
            current_route = [customer + 1]
            current_demand = demand

    if current_route:
        routes.append(current_route)

    return routes

# Função de avaliação (fitness)
def evaluate(individual, coords, demands, capacity):
    routes = split_routes(individual, demands, capacity)
    total_distance = 0

    for route in routes:
        if not route:
            continue
        total_distance += euclidean_distance(coords[0], coords[route[0]])
        for i in range(len(route) - 1):
            total_distance += euclidean_distance(coords[route[i]], coords[route[i + 1]])
        total_distance += euclidean_distance(coords[route[-1]], coords[0])

    return (total_distance,)

# Função para reparar indivíduos inválidos
def repair_individual(ind, n_customers):
    valid_indices = set(range(0, n_customers))
    current_indices = set(ind)
    ind[:] = [x for x in ind if 0 <= x < n_customers]
    missing = list(valid_indices - current_indices)
    random.shuffle(missing)
    ind.extend(missing[:n_customers - len(ind)])
    ind[:] = ind[:n_customers]
    return ind

# Função para plotar as rotas
def plot_routes(coords, routes, title="Rotas Otimizadas para o CVRP"):
    plt.figure(figsize=(10, 6))
    plt.scatter([coords[0][0]], [coords[0][1]], c='red', label='Depósito', s=100)
    for i in range(1, len(coords)):
        plt.scatter([coords[i][0]], [coords[i][1]], c='blue', s=50)
        plt.text(coords[i][0], coords[i][1], str(i), fontsize=8, ha='right')
    colors = ['green', 'blue', 'cyan', 'purple', 'yellow']
    for i, route in enumerate(routes):
        full_route = [0] + route + [0]
        x = [coords[c][0] for c in full_route]
        y = [coords[c][1] for c in full_route]
        plt.plot(x, y, color=colors[i % len(colors)], label=f'Rota {i+1}', linewidth=2)
    plt.title(title)
    plt.xlabel("Coordenada X")
    plt.ylabel("Coordenada Y")
    plt.legend()
    plt.grid(True)
    plt.show()

# Função para plotar a convergência do algoritmo genético
def plot_convergence(logbook):
    gen = logbook.select("gen")
    min_fitness = logbook.select("min")
    avg_fitness = logbook.select("avg")

    plt.figure(figsize=(10, 6))
    plt.plot(gen, min_fitness, label="Distância Mínima", color='blue')
    plt.plot(gen, avg_fitness, label="Distância Média", color='orange', linestyle='--')
    plt.title("Convergência do Algoritmo Genético")
    plt.xlabel("Geração")
    plt.ylabel("Distância")
    plt.legend()
    plt.grid(True)
    plt.show()

# Função para plotar comparação de distâncias
def plot_distance_comparison(distances, stages):
    plt.figure(figsize=(8, 5))
    bars = plt.bar(stages, distances, color=['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728'])
    plt.title("Comparação de Distâncias por Etapa")
    plt.xlabel("Etapa")
    plt.ylabel("Distância Total")
    plt.grid(True, axis='y', linestyle='--', alpha=0.7)
    for bar in bars:
        yval = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2, yval + 5, f'{yval:.2f}', ha='center', va='bottom')
    plt.show()

# Função para plotar demandas por rota
def plot_route_demands(routes, demands, capacity):
    route_demands = [sum(demands[c] for c in route) for route in routes]
    route_labels = [f'Rota {i+1}' for i in range(len(routes))]

    plt.figure(figsize=(10, 6))
    bars = plt.bar(route_labels, route_demands, color='skyblue')
    plt.axhline(y=capacity, color='red', linestyle='--', label=f'Capacidade Máxima ({capacity})')
    plt.title("Demandas por Rota")
    plt.xlabel("Rota")
    plt.ylabel("Demanda Total")
    plt.legend()
    plt.grid(True, axis='y', linestyle='--', alpha=0.7)
    for bar in bars:
        yval = bar.get_height()
        plt.text(bar.get_x() + bar.get_width()/2, yval + 2, f'{yval}', ha='center', va='bottom')
    plt.show()

# Função para plotar dispersão com demandas
def plot_scatter_with_demands(coords, routes, demands):
    plt.figure(figsize=(10, 6))
    max_demand = max(demands[1:])
    min_demand = min(demands[1:])
    sizes = [50 + 200 * (demands[i] - min_demand) / (max_demand - min_demand) for i in range(len(coords))]
    
    plt.scatter([coords[0][0]], [coords[0][1]], c='red', label='Depósito', s=100)
    for i in range(1, len(coords)):
        plt.scatter([coords[i][0]], [coords[i][1]], c='blue', s=sizes[i], alpha=0.6)
        plt.text(coords[i][0], coords[i][1], str(i), fontsize=8, ha='right')
    
    colors = ['green', 'blue', 'cyan', 'purple', 'yellow']
    for i, route in enumerate(routes):
        full_route = [0] + route + [0]
        x = [coords[c][0] for c in full_route]
        y = [coords[c][1] for c in full_route]
        plt.plot(x, y, color=colors[i % len(colors)], label=f'Rota {i+1}', linewidth=2)
    
    plt.title("Dispersão dos Clientes com Demandas e Rotas")
    plt.xlabel("Coordenada X")
    plt.ylabel("Coordenada Y")
    plt.legend()
    plt.grid(True)
    plt.show()

# Função para calcular a distância total de uma rota
def calculate_route_distance(route, coords):
    full_route = [0] + route + [0]
    distance = 0
    for i in range(len(full_route) - 1):
        x1, y1 = coords[full_route[i]]
        x2, y2 = coords[full_route[i + 1]]
        distance += np.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return distance

# Função 2-opt para melhorar uma rota individual
def two_opt(route, coords, demands, capacity):
    best_route = route.copy()
    best_distance = calculate_route_distance(best_route, coords)
    improved = True

    while improved:
        improved = False
        for i in range(1, len(best_route) - 1):
            for j in range(i + 1, len(best_route)):
                new_route = best_route[:i] + best_route[i:j+1][::-1] + best_route[j+1:]
                demand = sum(demands[c] for c in new_route)
                if demand <= capacity:
                    new_distance = calculate_route_distance(new_route, coords)
                    if new_distance < best_distance:
                        best_route = new_route
                        best_distance = new_distance
                        improved = True
        if not improved:
            break

    return best_route

# Função para aplicar 2-opt a todas as rotas
def two_opt_refinement(routes, coords, demands, capacity):
    refined_routes = []
    for route in routes:
        if len(route) > 1:
            refined_route = two_opt(route, coords, demands, capacity)
            refined_routes.append(refined_route)
        else:
            refined_routes.append(route)
    return refined_routes

# Função para troca inter-rotas
def inter_route_swap_refinement(routes, coords, demands, capacity):
    best_routes = [route.copy() for route in routes]
    best_distance = sum(calculate_route_distance(route, coords) for route in best_routes)

    for r1 in range(len(best_routes)):
        for r2 in range(r1 + 1, len(best_routes)):
            route1, route2 = best_routes[r1], best_routes[r2]
            for i in range(len(route1)):
                for j in range(len(route2)):
                    new_route1 = route1[:i] + [route2[j]] + route1[i+1:]
                    new_route2 = route2[:j] + [route1[i]] + route2[j+1:]
                    demand1 = sum(demands[c] for c in new_route1)
                    demand2 = sum(demands[c] for c in new_route2)
                    if demand1 <= capacity and demand2 <= capacity:
                        new_distance = (calculate_route_distance(new_route1, coords) +
                                       calculate_route_distance(new_route2, coords))
                        old_distance = (calculate_route_distance(route1, coords) +
                                       calculate_route_distance(route2, coords))
                        if new_distance < old_distance:
                            best_routes[r1] = new_route1
                            best_routes[r2] = new_route2
                            best_distance = sum(calculate_route_distance(route, coords) for route in best_routes)

    return best_routes

# Função para calcular o custo de uma rota (usada no CGN)
def calculate_route_cost(route, distances):
    cost = 0
    full_route = [0] + route + [0]
    for i in range(len(full_route) - 1):
        cost += distances[full_route[i]][full_route[i + 1]]
    return cost

# Função para gerar colunas iniciais (usando as rotas refinadas)
def generate_initial_columns(refined_routes, distances):
    columns = []
    for route in refined_routes:
        cost = calculate_route_cost(route, distances)
        columns.append((route, cost))
    return columns

# Função para resolver o problema mestre
def solve_master_problem(columns, demands, num_customers):
    prob = LpProblem("Master_Problem", LpMinimize)
    x = {i: LpVariable(f"x_{i}", 0, 1, LpBinary) for i in range(len(columns))}
    prob += lpSum(columns[i][1] * x[i] for i in range(len(columns)))
    for customer in range(1, num_customers + 1):
        prob += (
            lpSum(x[i] for i in range(len(columns)) if customer in columns[i][0]) == 1,
            f"Cover_{customer}"
        )
    prob.solve()
    duals = {c.name: c.pi for c in prob.constraints.values()}
    duals = {int(name.split("_")[1]): val for name, val in duals.items()}
    selected_routes = []
    for i in range(len(columns)):
        if x[i].varValue > 0.5:
            selected_routes.append(columns[i][0])
    return selected_routes, duals

# Função para resolver o problema de precificação (heurística gulosa ajustada)
def pricing_problem(duals, distances, demands, capacity, num_customers):
    best_route = []
    best_reduced_cost = float('inf')
    visited = set([0])  # Depósito já visitado
    
    # Tentar construir várias rotas e escolher a melhor
    for _ in range(10):  # Aumentar para 10 tentativas
        route = []
        current_demand = 0
        current_cost = 0
        current_node = 0
        
        # Lista de clientes não visitados
        unvisited = set(range(1, num_customers + 1)) - visited
        
        while unvisited:
            candidates = []
            for next_node in unvisited:
                if current_demand + demands[next_node] <= capacity:
                    edge_cost = distances[current_node][next_node]
                    reduced_cost = edge_cost - duals.get(next_node, 0)
                    # Introduzir um incentivo para rotas mais longas
                    length_bonus = 0.1 * len(route)  # Pequeno bônus por cliente adicionado
                    adjusted_reduced_cost = reduced_cost - length_bonus
                    candidates.append((next_node, adjusted_reduced_cost, edge_cost))
            
            if not candidates:
                break
            
            # Escolher o próximo cliente com uma combinação de custo reduzido e aleatoriedade
            candidates.sort(key=lambda x: x[1])  # Ordenar por custo reduzido ajustado
            top_candidates = candidates[:min(3, len(candidates))]  # Pegar os 3 melhores
            next_node, _, edge_cost = random.choice(top_candidates)  # Escolher aleatoriamente entre os melhores
            
            route.append(next_node)
            unvisited.remove(next_node)
            current_demand += demands[next_node]
            current_cost += edge_cost
            current_node = next_node
        
        # Voltar ao depósito
        if route:
            current_cost += distances[current_node][0]
        
        # Calcular o custo reduzido total da rota
        reduced_cost = current_cost - sum(duals.get(c, 0) for c in route)
        
        # Atualizar a melhor rota encontrada
        if reduced_cost < best_reduced_cost:
            best_reduced_cost = reduced_cost
            best_route = route
    
    return best_route, current_cost if route else 0, best_reduced_cost

# Função principal do CGN
def column_generation(refined_routes, distances, demands, capacity, num_customers, max_iterations=20):
    columns = generate_initial_columns(refined_routes, distances)
    iteration = 0
    while iteration < max_iterations:
        print(f"Iteração {iteration + 1} do CGN...")
        selected_routes, duals = solve_master_problem(columns, demands, num_customers)
        print(f"Rotas selecionadas na iteração {iteration + 1}: {selected_routes}")
        new_route, cost, reduced_cost = pricing_problem(duals, distances, demands, capacity, num_customers)
        print(f"Nova rota gerada: {new_route}, Custo: {cost}, Custo Reduzido: {reduced_cost}")
        if reduced_cost < -0.01 and len(new_route) > 0:
            columns.append((new_route, cost))
            iteration += 1
        else:
            print("Nenhuma rota com custo reduzido negativo encontrada ou rota inválida. Parando o CGN.")
            break
    prob = LpProblem("Master_Problem_Final", LpMinimize)
    x = {i: LpVariable(f"x_{i}", 0, 1, LpBinary) for i in range(len(columns))}
    prob += lpSum(columns[i][1] * x[i] for i in range(len(columns)))
    for customer in range(1, num_customers + 1):
        prob += (
            lpSum(x[i] for i in range(len(columns)) if customer in columns[i][0]) == 1,
            f"Cover_{customer}"
        )
    prob.solve()
    final_routes = []
    total_cost = 0
    for i in range(len(columns)):
        if x[i].varValue > 0.5:
            final_routes.append(columns[i][0])
            total_cost += columns[i][1]
    return final_routes, total_cost

# Função para aplicar busca por vizinhança
def apply_neighborhood_search(routes, coords, demands, capacity, distances):
    refined_routes = routes.copy()
    for _ in range(3):
        refined_routes = two_opt_refinement(refined_routes, coords, demands, capacity)
        refined_routes = inter_route_swap_refinement(refined_routes, coords, demands, capacity)
        if not validate_routes(refined_routes, demands, capacity):
            raise ValueError("Busca por vizinhança gerou rotas inválidas!")
    return refined_routes

# Função para validar rotas
def validate_routes(routes, demands, capacity):
    all_customers = set()
    for route in routes:
        for customer in route:
            if customer in all_customers:
                print(f"Erro: Cliente {customer} duplicado nas rotas!")
                return False
            all_customers.add(customer)
    if set(range(1, len(demands))) != all_customers:
        print(f"Erro: Nem todos os clientes estão cobertos! Cobertos: {sorted(all_customers)}")
        return False
    for i, route in enumerate(routes):
        demand = sum(demands[c] for c in route)
        print(f"Rota {i+1} ({route}): Demanda = {demand}")
        if demand > capacity:
            print(f"Erro: Rota {i+1} ({route}) excede a capacidade {capacity}: Demanda = {demand}")
            return False
    return True

# Configurações do DEAP
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))
creator.create("Individual", list, fitness=creator.FitnessMin)

toolbox = base.Toolbox()

# Carregar a instância
url = "http://vrp.atd-lab.inf.puc-rio.br/media/com_vrp/instances/A/A-n32-k5.vrp"
coords, demands, capacity = load_cvrp_instance(url)

# Calcular a matriz de distâncias
distances = calculate_distance_matrix(coords)

# Verificar consistência dos dados
print(f"Len coords: {len(coords)}, Len demands: {len(demands)}, Capacity: {capacity}")
n_customers = len(coords) - 1
print(f"n_customers: {n_customers}")

# Configurar o DEAP
toolbox.register("indices", random.sample, range(0, n_customers), n_customers)
toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.indices)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)
toolbox.register("mate", tools.cxPartialyMatched)
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=0.05)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", evaluate, coords=coords, demands=demands, capacity=capacity)

# Função principal
def main(toolbox, distances):
    pop = toolbox.population(n=100)
    hof = tools.HallOfFame(1)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", np.mean)
    stats.register("min", np.min)
    pop, log = algorithms.eaSimple(pop, toolbox, cxpb=0.7, mutpb=0.2, ngen=50, stats=stats, halloffame=hof, verbose=True)

    # Plotar a convergência do algoritmo genético
    plot_convergence(log)
    ga_distance = hof[0].fitness.values[0]

    # Obter a melhor solução
    best_individual = hof[0]
    routes = decode_individual(best_individual, demands, capacity)
    print("Rotas após algoritmo genético:", routes)
    print("Demandas após algoritmo genético:")
    for i, route in enumerate(routes):
        demand = sum(demands[c] for c in route)
        print(f"Rota {i+1} ({route}): Demanda = {demand}")
    print("Validando rotas após algoritmo genético...")
    if not validate_routes(routes, demands, capacity):
        raise ValueError("Rotas inválidas após algoritmo genético!")
    plot_routes(coords, routes, title="Rotas Após Algoritmo Genético")

    # Refinar com 2-opt e inter-troca
    refined_routes = two_opt_refinement(routes, coords, demands, capacity)
    refined_routes = inter_route_swap_refinement(refined_routes, coords, demands, capacity)
    refined_distance = sum(calculate_route_cost(route, distances) for route in refined_routes)
    print(f"Melhor distância após refinamento inicial: {refined_distance}")
    print(f"Rotas refinadas iniciais: {refined_routes}")
    print("Validando rotas após refinamento inicial...")
    if not validate_routes(refined_routes, demands, capacity):
        raise ValueError("Rotas inválidas após refinamento inicial!")
    plot_routes(coords, refined_routes, title="Rotas Após Refinamento Inicial")

    # Aplicar o CGN
    print("\nIniciando o CGN...")
    cgn_routes, cgn_distance = column_generation(refined_routes, distances, demands, capacity, num_customers=31)
    print(f"Melhor distância após CGN: {cgn_distance}")
    print(f"Rotas após CGN: {cgn_routes}")
    print("Validando rotas após CGN...")
    if not validate_routes(cgn_routes, demands, capacity):
        raise ValueError("Rotas inválidas após CGN!")
    plot_routes(coords, cgn_routes, title="Rotas Após CGN")

    # Aplicar busca por vizinhança (2-opt e inter-troca) novamente
    final_routes = apply_neighborhood_search(cgn_routes, coords, demands, capacity, distances)
    final_distance = sum(calculate_route_cost(route, distances) for route in final_routes)
    print(f"Melhor distância final após busca por vizinhança: {final_distance}")
    print(f"Rotas finais: {final_routes}")
    print("Validando rotas finais...")
    if not validate_routes(final_routes, demands, capacity):
        raise ValueError("Rotas inválidas após busca por vizinhança!")

    # Plotar gráficos adicionais
    # 1. Comparação de distâncias
    distances_list = [ga_distance, refined_distance, cgn_distance, final_distance]
    stages = ["Algoritmo Genético", "Refinamento Inicial", "CGN", "Busca por Vizinhança"]
    plot_distance_comparison(distances_list, stages)

    # 2. Demandas por rota
    plot_route_demands(final_routes, demands, capacity)

    # 3. Dispersão com demandas
    plot_scatter_with_demands(coords, final_routes, demands)

    # 4. Rotas finais
    plot_routes(coords, final_routes, title="Rotas Finais")

    return pop, log, hof, final_routes

if __name__ == "__main__":
    pop, log, hof, refined_routes = main(toolbox, distances)
    print("Rotas refinadas finais:", refined_routes)